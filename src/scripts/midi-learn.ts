/**
 * MIDI Learn Mode
 * 
 * Listens to MIDI input and logs CC messages as you turn knobs.
 * Also sends Identity Request to detect synth manufacturer/model.
 * Useful for discovering CC mappings on undocumented synths.
 * 
 * Usage:
 *   npm run midi:learn              # Just scan and display
 *   npm run midi:learn -- --export  # Also generate param-map skeleton
 */

import midi from 'midi';
import { writeFileSync, mkdirSync } from 'fs';
import { listMidiInputs, listMidiOutputs } from '../midi/hardware-port.js';

interface CCMessage {
  channel: number;
  cc: number;
  value: number;
  timestamp: number;
}

interface SynthIdentity {
  manufacturer: string;
  manufacturerId: number[];
  family: number[];
  model: number[];
  version: number[];
  raw: number[];
}

// Common manufacturer IDs (first byte or 3-byte extended)
const MANUFACTURERS: Record<string, string> = {
  '1': 'Sequential',
  '4': 'Moog',
  '6': 'Lexicon',
  '7': 'Kurzweil',
  '15': 'Ensoniq',
  '16': 'Oberheim',
  '24': 'Emu',
  '41': 'Korg',
  '43': 'Yamaha',
  '66': 'Kawai',
  '71': 'Roland',
  '0,0,7': 'Digitech',
  '0,0,14': 'Alesis',
  '0,0,27': 'Novation',
  '0,0,107': 'Moog Music',
  '0,32,27': 'Waldorf',
  '0,32,50': 'Teenage Engineering',
  '0,32,107': 'Arturia',
  '0,33,2': 'Elektron',
};

const seenCCs: Map<string, CCMessage> = new Map();
let synthIdentity: SynthIdentity | null = null;
const shouldExport = process.argv.includes('--export');

function formatCC(msg: CCMessage): string {
  return `CH ${msg.channel + 1} | CC ${msg.cc.toString().padStart(3)} | Value ${msg.value.toString().padStart(3)}`;
}

function parseIdentityReply(message: number[]): void {
  // Identity Reply format: F0 7E <device> 06 02 <mfr> <family> <model> <version> F7
  // Manufacturer can be 1 byte or 3 bytes (if first byte is 0x00)
  
  let idx = 5; // Start after F0 7E xx 06 02
  let manufacturerId: number[] = [];
  
  if (message[idx] === 0x00) {
    // Extended 3-byte manufacturer ID
    manufacturerId = [message[idx], message[idx + 1], message[idx + 2]];
    idx += 3;
  } else {
    // Single byte manufacturer ID
    manufacturerId = [message[idx]];
    idx += 1;
  }
  
  const family = [message[idx], message[idx + 1]];
  const model = [message[idx + 2], message[idx + 3]];
  const version = [message[idx + 4], message[idx + 5], message[idx + 6], message[idx + 7]];
  
  const mfrKey = manufacturerId.join(',');
  const manufacturer = MANUFACTURERS[mfrKey] || `Unknown (${mfrKey})`;
  
  synthIdentity = {
    manufacturer,
    manufacturerId,
    family,
    model,
    version,
    raw: message,
  };
  
  console.log('\nðŸŽ¹ SYNTH IDENTIFIED:');
  console.log(`   Manufacturer: ${manufacturer}`);
  console.log(`   Family: ${family.map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
  console.log(`   Model: ${model.map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
  console.log(`   Version: ${version.map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
  console.log('');
}

function generateParamMapFile(): string {
  const synthName = synthIdentity?.manufacturer ?? 'Unknown';
  const safeName = synthName.toLowerCase().replace(/[^a-z0-9]/g, '');
  const className = synthName.replace(/[^a-zA-Z0-9]/g, '');
  const version = synthIdentity?.version.join('.') ?? 'unknown';
  
  const sortedCCs = Array.from(seenCCs.values()).sort((a, b) => a.cc - b.cc);
  
  const ccEntries = sortedCCs.map(msg => 
    `  UNKNOWN_CC_${msg.cc}: ${msg.cc},`
  ).join('\n');
  
  const paramEntries = sortedCCs.map(msg =>
    `  // 'unknown.param': ${className}CC.UNKNOWN_CC_${msg.cc},`
  ).join('\n');
  
  return `/**
 * ${synthName} Parameter Map
 * 
 * Auto-generated by midi-learn on ${new Date().toISOString()}
 * Synth Version: ${version}
 * 
 * TODO: Rename UNKNOWN_CC_* constants to meaningful names
 * TODO: Map to canonical parameters in paramToCC
 */

import type { CanonicalParam } from '../../synth/types.js';

/**
 * ${synthName} CC assignments (discovered via MIDI learn).
 * Rename these to meaningful parameter names.
 */
export const ${className}CC = {
${ccEntries}
} as const;

/**
 * Map from canonical parameters to ${synthName} CC numbers.
 * Fill this in once you identify what each CC controls.
 */
export const paramToCC: Partial<Record<CanonicalParam, number>> = {
${paramEntries}
};

/**
 * Get the CC number for a canonical parameter.
 */
export function getCCForParam(param: CanonicalParam): number | undefined {
  return paramToCC[param];
}

/**
 * List of all supported canonical parameters.
 */
export function getSupportedParams(): CanonicalParam[] {
  return Object.keys(paramToCC) as CanonicalParam[];
}
`;
}

function exportParamMap(): void {
  const synthName = synthIdentity?.manufacturer ?? 'unknown';
  const safeName = synthName.toLowerCase().replace(/[^a-z0-9]/g, '');
  const dirPath = `src/drivers/${safeName}`;
  const filePath = `${dirPath}/param-map.generated.ts`;
  
  try {
    mkdirSync(dirPath, { recursive: true });
    const content = generateParamMapFile();
    writeFileSync(filePath, content);
    console.log(`\nðŸ“ Exported param-map skeleton to: ${filePath}`);
  } catch (err) {
    console.error(`\nâŒ Failed to export param-map:`, err);
  }
}

async function main() {
  console.log('\nðŸŽ“ Patchwork MIDI Learn Mode\n');
  console.log('Wiggle knobs on your synth to discover CC mappings.\n');
  console.log('Press Ctrl+C to exit and see summary.\n');
  console.log('â”€'.repeat(50));

  // List available inputs
  const ports = listMidiInputs();
  if (ports.length === 0) {
    console.log('âŒ No MIDI input devices found.');
    process.exit(1);
  }

  console.log('Available MIDI inputs:');
  ports.forEach((p, i) => console.log(`  ${i}: ${p}`));

  // Find MicroFreak or use first available
  let portIndex = ports.findIndex(p => 
    p.toLowerCase().includes('microfreak') || 
    p.toLowerCase().includes('arturia')
  );
  
  if (portIndex === -1) {
    portIndex = 0;
    console.log(`\nâš ï¸  MicroFreak not found, using: "${ports[0]}"`);
  } else {
    console.log(`\nâœ“ Found: "${ports[portIndex]}"`);
  }

  // Open input with SysEx enabled
  const input = new midi.Input();
  input.ignoreTypes(false, false, false); // Enable SysEx, timing, active sensing
  input.openPort(portIndex);

  // Try to find matching output port for identity request
  const outputPorts = listMidiOutputs();
  const outputIndex = outputPorts.findIndex(p => 
    p.toLowerCase().includes(ports[portIndex].toLowerCase().split(' ')[0])
  );
  
  let output: midi.Output | null = null;
  if (outputIndex !== -1) {
    output = new midi.Output();
    output.openPort(outputIndex);
    
    // Send Identity Request: F0 7E 7F 06 01 F7
    console.log('\nðŸ“¡ Sending Identity Request...');
    const identityRequest = [0xf0, 0x7e, 0x7f, 0x06, 0x01, 0xf7];
    output.sendMessage(identityRequest as unknown as [number, number, number]);
  }
  
  console.log('\nðŸŽ›ï¸  Listening for CC messages...\n');

  // Handle incoming messages
  input.on('message', (deltaTime: number, message: number[]) => {
    const [status, data1, data2] = message;
    
    // Check for SysEx Identity Reply: F0 7E xx 06 02 ...
    if (message[0] === 0xf0 && message[1] === 0x7e && message[3] === 0x06 && message[4] === 0x02) {
      parseIdentityReply(message);
      return;
    }
    
    // Check if it's a CC message (0xB0-0xBF)
    if ((status & 0xf0) === 0xb0) {
      const channel = status & 0x0f;
      const cc = data1;
      const value = data2;
      
      const key = `${channel}-${cc}`;
      const msg: CCMessage = { channel, cc, value, timestamp: Date.now() };
      
      const isNew = !seenCCs.has(key);
      seenCCs.set(key, msg);
      
      if (isNew) {
        console.log(`âœ¨ NEW  ${formatCC(msg)}`);
      } else {
        // Overwrite same line for updates
        process.stdout.write(`\r   â†’   ${formatCC(msg)}    `);
      }
    }
    
    // Also log note messages for reference
    if ((status & 0xf0) === 0x90 && data2 > 0) {
      console.log(`\nðŸŽ¹ Note On: ${data1} vel ${data2}`);
    }
  });

  // Handle exit
  process.on('SIGINT', () => {
    console.log('\n\n' + 'â”€'.repeat(50));
    
    // Print synth identity if we got one
    if (synthIdentity) {
      console.log('\nðŸŽ¹ Synth Identity:\n');
      console.log(`   Manufacturer: ${synthIdentity.manufacturer}`);
      console.log(`   Manufacturer ID: ${synthIdentity.manufacturerId.map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')}`);
      console.log(`   Family: ${synthIdentity.family.map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')}`);
      console.log(`   Model: ${synthIdentity.model.map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')}`);
      console.log(`   Version: ${synthIdentity.version.map(b => b.toString()).join('.')}`);
    }
    
    console.log('\nðŸ“‹ CC Summary - Discovered mappings:\n');
    
    const sorted = Array.from(seenCCs.values())
      .sort((a, b) => a.cc - b.cc);
    
    if (sorted.length === 0) {
      console.log('   (no CCs detected)');
    } else {
      console.log('   CC#  | Last Value | Channel');
      console.log('   â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€');
      for (const msg of sorted) {
        console.log(`   ${msg.cc.toString().padStart(3)}  |    ${msg.value.toString().padStart(3)}     |   ${msg.channel + 1}`);
      }
    }
    
    console.log(`\nâœ“ Discovered ${sorted.length} unique CC parameters.\n`);
    
    // Export param-map if requested
    if (shouldExport && sorted.length > 0) {
      exportParamMap();
    } else if (shouldExport && sorted.length === 0) {
      console.log('âš ï¸  No CCs discovered, skipping export.');
    }
    
    if (output) {
      output.closePort();
    }
    input.closePort();
    process.exit(0);
  });
}

main().catch(err => {
  console.error('Error:', err);
  process.exit(1);
});
